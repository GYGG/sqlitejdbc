--- sqlite-3.3.8-nestedvm/main.c	2006-10-09 03:50:59.000000000 +1000
+++ main.c	2006-11-27 10:06:10.000000000 +1000
@@ -1199,6 +1199,21 @@
 ** See comment in sqlite3.h (sqlite.h.in) for details.
 */
 #ifdef SQLITE_ENABLE_COLUMN_METADATA
+int column_metadata_helper(
+  sqlite3 *db,
+  sqlite3_stmt *stmt,
+  int col,
+  struct metadata *p
+){
+  const char *zTableName, *zColumnName;
+  zTableName = sqlite3_column_table_name(stmt, col);
+  zColumnName = sqlite3_column_name(stmt, col);
+  return sqlite3_table_column_metadata(
+    db, 0, zTableName, zColumnName, 0, 0,
+    &p->pNotNull, &p->pPrimaryKey, &p->pAutoinc
+  );
+}
+
 int sqlite3_table_column_metadata(
   sqlite3 *db,                /* Connection handle */
   const char *zDbName,        /* Database name or NULL */
--- sqlite-3.3.8-nestedvm/sqlite3.h	2006-10-09 03:50:59.000000000 +1000
+++ sqlite3.h	2006-11-27 10:07:41.000000000 +1000
@@ -1519,6 +1519,7 @@
   int *pAutoinc               /* OUTPUT: True if colums is auto-increment */
 );
 
+
 /*
 ****** EXPERIMENTAL - subject to change without notice **************
 **
@@ -1820,6 +1821,21 @@
 # undef double
 #endif
 
+/* Provides access to metadata across NestedVM 7-argument limit on functions.*/
+struct metadata {
+  int pNotNull;
+  int pPrimaryKey;
+  int pAutoinc;
+};
+
+int column_metadata_helper(
+  sqlite3 *db,
+  sqlite3_stmt *stmt,
+  int col,
+  struct metadata *p
+);
+
+
 #ifdef __cplusplus
 }  /* End of the 'extern "C"' block */
 #endif
--- main.c	2006-11-27 23:09:41.000000000 +1100
+++ sqlite-3.3.8-nestedvm/main.c	2006-11-27 23:37:05.000000000 +1100
@@ -1348,3 +1348,29 @@
   db->errMask = onoff ? 0xffffffff : 0xff;
   return SQLITE_OK;
 }
+
+extern int _call_java(int xType, int context, int args, int value);
+
+void xFunc_helper(sqlite3_context *context, int args, sqlite3_value** value)
+{
+    _call_java(1, (int)context, args, (int)value);
+}
+
+void xStep_helper(sqlite3_context *context, int args, sqlite3_value** value)
+{
+    _call_java(2, (int)context, args, (int)value);
+}
+
+void xFinal_helper(sqlite3_context *context)
+{
+    _call_java(3, (int)context, 0, 0);
+}
+
+/* create function if pos is non-negative, aggregate if agg is true */
+int create_function_helper(sqlite3 *db, const char *name, int pos, int agg)
+{
+    return sqlite3_create_function(db, name, -1, SQLITE_ANY, (void*)pos,
+            pos>=0 ? &xFunc_helper : 0,
+            pos>=0 && agg ? &xStep_helper : 0,
+            pos>=0 && agg ? &xFinal_helper : 0);
+}
